{"atitle":"Shadermodel 3.0","boxes":[{"border":"5px solid rgb(100, 218, 255)","hasborder":true,"chapter":"Introduction to Shadermodel 3.0","text":"<div>The successor to shadermodel 2.0</div><div>Usually in Source that one is named 20b or 2_0b.</div><div><br></div><div>So why is it the successor? Lets look at some differences and how it works.</div>","iscode":false,"isvdccode":false,"contents":[]},{"border":"5px solid rgb(100, 218, 255)","hasborder":true,"chapter":"Difference in Constant Registers","text":"<div>The Pixelshader Constant Registers.</div><div>A pixel shader constant register is basically a memory address that has a value set onto GPU memory.<br></div><div>Also known as PSREG's, they store an array of numbers ( arrays of 4 )</div><div>There are a multitude of these. Those specific for Floats and those specific for Booleans and Integers</div><div>ps20b in source supports 32 float constant registers ( to a total of 128 floats )</div><div><br></div><div>in theory they support 16 boolean and 16 integer constant registers at the same time as well, however I'm not going out of my way to confirm whether or not source allows for this.<br>None of the stock Shader's use boolean and integer constant registers.</div><div><br></div><div>By comparison Shadermodel 3.0 supports up to 224 float registers ( Whopping 700% more than 20b!! )</div><div>plus the additional 16 boolean and 16 integer constant registers ( whichs a total of 256 btw )</div><div><br></div><div><b>SOURCE BY DEFAULT ONLY ALLOWS FOR 32 FLOAT CONSTANT REGISTERS ON SM3.0</b></div><div>If you desire more constant registers implement <a href=\"https://github.com/Nbc66/source-sdk-2013-ce/commit/e39cceab4fb8199a1ba7927de27069bf8b8f6883\">THIS</a> commit.<br>Its a hack revealed by Ficool2 that ups the limit.</div><div>Some Valve programmer implemented a check for shadermodel 2.0b support and then limits to 32 constants. Which is not the maximum supported by 3.0!!!</div><div><br></div><div><b>ATTEMPTING TO SET A CONSTANT REGISTER ABOVE 0-31 WITHOUT HAVING THIS WILL CRASH YOUR GAME </b></div><div><i>You can disregard this message if you are on Alien Swarm</i><b> or newer source branches<br></b></div>","iscode":false,"isvdccode":false,"contents":[]},{"border":"5px solid rgb(100, 218, 255)","hasborder":true,"chapter":"Shader Functions ( Boolean )","text":"all(x) - Tests if ALL components of x are nonzero. I guess this means if you flop a float of 0.1 into it, it would return a true<br>any(x) - Test if ANY component of x are nonzero.<br><br>isfinite(x) -\treturns true if finite.<br>isinf(x)\t-\treturns true if infinite.<br>\t\t\t\tYou may ask yourself how can a floating point value with a maximum given length NOT be finite?<br>\t\t\t\tTottery explained it to me.<br>\t\t\t\tBasically : 32/64 bit numbers are packed as SIGN, EXPONENT, FRACTION<br>\t\t\t\t\t\t\tActually retrieving the value would look like this : sign * (2^exponent + fraction)<br>\t\t\t\t\t\t\tAnd these two values would equal to infinite<br>\t\t\t\t\t\t\tPositive Infinity - Sign = 0, Exponent = 128, fraction = 000 0000 0000 0000 0000 0000<br>\t\t\t\t\t\t\tNegative Infinity - Sign = 1, Exponent = 128, fraction = 000 0000 0000 0000 0000 0000<br><div>\t\t\t\tQuake 3's fast square root implementation takes advantage of this,</div><div>                                by manipulating the bits that represent the exponent like so</div>\t\t\t\t\t\tint i = *(int*)&amp;x;\t\ti = 0x5f3759df - (i&gt;&gt;1);<br>\t\t\t\t\tIn the actual code there is a comment apparently, left by John Carmack, that just says : // what the fuck?<br><br>isnan()\t\t-\treturns true if nan or qnan. for example Sign = *, exponent = 128, fraction = non zero. Actual value = NaN<br>idexp()\t\t-\treturns x *2exp<br>step(x,y)          -\treturns 1 if y is greater than or equal to x, otherwise 0","iscode":false,"isvdccode":false,"contents":[]},{"border":"5px solid rgb(100, 218, 255)","hasborder":true,"chapter":"Shader Functions ( Trigono. )","text":"asin(x)\t\t- Returns arc sine of each component<br>acos(x)\t\t- Returns arc cosine of each component<br>atan(x)\t\t- Returns arc tan of each component<br>atan2(x)\t- Returns the arctangent of two values (x,y)<br>cos(x)\t\t- Returns cosine<br>cosh(x)\t\t- Returns hyperbolic cosine <br>sin(x)\t\t- Be sent to hell immediately<br>sincos(x, s, c)\t- Returns the sine and cosine of x. Where s and c are outputs<br>sinh(x)\t\t- ... hyperbolic<br>tan(x)\t\t- Returns tan of each component<br>tanh(x)\t\t- ... hyperbolic","iscode":false,"isvdccode":false,"contents":[]},{"border":"5px solid rgb(100, 218, 255)","hasborder":true,"chapter":"Shader Functions ( Integer )","text":"dot(x,y)\t\t\t\t- Dot product of two values ( floats are also supported ). Equates to (ax * bx) + (ay * bx) + (ax * by) + (ay * by)... or more simply... (ax * bx + ay * by)... Returns both x AND y<br>round(x)\t\t\t\t- rounds to integer<br>sign(x)\t\t\t\t\t- returns -1 if x &lt; 0, 0 if x = 0, and 1 if x &gt; 0 -- this could be very handy for makeshift boolean math thingies. For example using the result to lerp a value<br>trunc(x)\t\t\t\t- returns an integer from a float by removing the fraction part. 15.3982 would return 15. This is NOT floor(), that one still returns a float!!<br><br>","iscode":false,"isvdccode":false,"contents":[]},{"border":"5px solid rgb(100, 218, 255)","hasborder":true,"chapter":"Shader Functions ( Float )","text":"clamp(x, min, max)\t\t- Returns clamped value. Where min is the minimum value it can have and max the maximum value.<br>clip(x)\t\t\t\t\t- Discards the pixel if any component of it is 0<br>ddx(x)\t\t\t\t\t- computes the partial derivative with respect to the screen-space x-coordinate. I guess you can manually compute UV positions with this(?)<br>ddy(x)\t\t\t\t\t- computes the partial derivative with respect to the screen-space y-coordinate. I guess you can manually compute UV positions with this(?)<br>degrees(x)\t\t\t\t- Turns Radians to Degrees<br>radians(x)\t\t\t\t- opposite to degrees(x)<br>distance(x,y)\t\t\t- Returns the Distance between two points. ( also works with vectors )<br>dot(x,y)\t\t\t\t- Dot product of two values ( integers are also supported ). Equates to (ax * bx) + (ay * bx) + (ax * by) + (ay * by)... or more simply... (ax * bx + ay * by)... Returns both x AND y<br>exp(x)\t\t\t\t\t- base-e exponential of the given value<br>exp2(x)\t\t\t\t\t- base-2 expontential of the given value. The 2^x of x<br>faceforward(n, i, ng)\t-\tn = the result will be stored to this, surface-normal vector,<br>\t\t\t\t\t\t\ti = incident vector facing from view position to shading position,<br>\t\t\t\t\t\t\tng = surface-normal vector.<br>\t\t\t\t\t\t  Flips the surface normal IF ng does NOT face away from i. ( n is ng but faces opposite to i ) - Equation for the function = sign(dot(i, ng))<br>\t\t\t\t\t\t  <br>floor(x)\t\t\t\t- returns the greatest integer value which is less than or equal to x. X = 12.15 - result = 12. In non fancy words: it will remove things after the comma.<br>frexp(x, exp)\t\t\t- returns mantissa and the value that exp() would give you for input exp, mantissa is a fancy for Significand, what it does is some fancy math crap where it returns the binary value *2^6<br>\t\t\t\t\t\t\tBASICALLY : look it up on google<br><br>fwidth(x)\t\t\t\t- Does the abs(ddx(x)) + abs(ddy(x)). If it isn't obvious, it gives you an absolute screenspace location<br>fmod(x,y)\t\t\t\t- A popular portal... nvm... floating point remainder of x is divided by y<br>\t\t\t\t\t\t\tThe floating-point remainder is calculated such that x = i * y + f, where i is an integer, f has the same sign as x, and the absolute value of f is less than the absolute value of y.<br>\t\t\t\t\t\t\t<br>frac(x)\t\t\t\t\t- Strip x from integer values. Aka whatever floatvalue you throw in, you receive something thats smaller than 1, or equal to 0. Examples 15.0015 = 0.0015, 1.0015 = 0.0015, 0.9999 = 0.9999, 1 = 0.<br>lerp(x,y,s)\t\t\t\t- x + s( y - x ). \"blends\" x and y based on s. Remember this equation and you can explain the universe.<br>log()\t\t\t\t\t-\\<br>log10()\t\t\t\t\t -&gt; logarithmic functions<br>log2()\t\t\t\t\t-/<br>modf(x,y)\t\t\t\t- returns integer and fraction portion of x. Y will return as the integer portion<br>min(x,y)\t\t\t\t- returns the smaller from the two. ( Whichever value is smaller than the other will be returned )<br>max(x,y)\t\t\t\t- returns the bigger from the two. ( Whichever value is bigger than the other will be returned )<br>noise()\t\t\t\t\t- generates a random value using perlin noise<br>pow(x,y)\t\t\t\t- x^y<br>sqrt(x)\t\t\t\t\t- returns square root<br>rsqrt(x)\t\t\t\t- returns 1 / sqrt(x)<br>saturate(x)\t\t\t\t- clamps x so that it never goes below 0 and never above 1<br>smoothstep(min, max, x) - clamps between the given values, if smaller than min it outputs min and vice versa. This can be used to blend two colors smoothly<br>ceil(x)\t\t\t\t\t- Returns the smallest integer value that is greater or equal to x | ceil(15.39) will return 39 as an integer ( the function should be called ceiling() because it does the opposite to floor() )<br>floor(x)\t\t\t\t- returns the greatest integer value of a float which is less than or equal to x. X = 12.15 - result = 12. In non fancy words: it will remove things after the comma.\t<br>abs() - Absolute Value, will take any negative float and simply remove negativity, turning the value into a positive one<br><br>","iscode":false,"isvdccode":false,"contents":[]},{"border":"5px solid rgb(100, 218, 255)","hasborder":true,"chapter":"Shader Functions ( Vector )","text":"cross(x,y)\t\t\t\t\t-\tReturns cross product of two values<br>D3DCOLORtoUBYTE4(x)\t\t-\tWill convert input vector to integer output for older hardware. ( turns a float3 to a int3 )<br>distance(x,y)\t\t\t\t\t-\tReturns the Distance between two points. ( also works with floats )<br>length()\t\t\t\t\t\t-\tSame as above but <br>lit(ambient, diffuse, specular)\t-\tReturns a lighting coefficient vector<br>\t\t\t\t\t\t\t\t\twhere : <br>\t\t\t\t\t\t\t\t\tambient\t\t= The dot product of the normalized surface normal and the light vector<br>\t\t\t\t\t\t\t\t\tdiffuse\t\t= The dot product of the half-angle vector and the surface normal.<br>\t\t\t\t\t\t\t\t\tspecular         = specular exponent<br>\t\t\t\t\t\t\t\t\tResult\t\t= ambient = 1, diffuse = n · l &lt; 0 ? 0 : n · l, specular = n · l &lt; 0 || n · h &lt; 0 ? 0 : (n · h) ^ m<br>\t\t\t\t\t\t\t\t\t<br>normalize(x)\t\t\t\t\t- normalizes a vector. This usually has to be done when you make a new vector from two vectors ( subtracting or adding two vectors together )<br>reflect(x,y)\t\t\t\t\t- returns a reflection vector. ( basically incoming angle = outgoing angle ), where x is incident vector, y is normal vector. Calculates as v = x - 2 * y * dot(x y)<br>refract(x,y,z)\t\t\t\t\t- refraction vector. Where x is ray direction vector, y is surface normal vector, z is refraction index<br><br>","iscode":false,"isvdccode":false,"contents":[]},{"border":"5px solid rgb(100, 218, 255)","hasborder":true,"chapter":"Shader Functions ( Matrix )","text":"determinant(x)\t\t-\tReturns the determinant of x. The Determinant is a scalar value.<br>\t\t\t\t\t\tScalar being a element of a field that defines a vector space and determinant being non-zero only IF the matrix is **invertible** and the linear map<br>\t\t\t\t\t\trepresented by the matrix is an isomorphism. Basically look up wikipedia it has some math examples of this<br>mul(x,y)\t\t\t-\tMatrix multiplication<br>transpose(x)\t\t-\tRotates a matrix. Think of it like this, if it was xy before, it will now be yx. It will basically invert the matrix. That means for a 3x3 matrix, the value on 2x2 will stay at the same location<br><br>","iscode":false,"isvdccode":false,"contents":[]},{"border":"5px solid rgb(100, 218, 255)","hasborder":true,"chapter":"Shader Functions ( Texture )","text":"tex1D(sampler, uv)\t\t\t\t- texture look up<br>tex1D(sampler, uv, ddx, ddy)\t\t- same as above but using a gradient to select the mip level<br>tex1Dbias(sampler, uv)\t\t\t- biases by uv.w<br>tex1Dgrad\t(sampler, uv, ddx, ddy)\t- samples by gradient, where ddx and ddy are the rate of change of the surface geometry in the respective direction.<br>tex1Dlod(sampler, uv)\t\t\t\t- texture look up but uv.w is lod level to grab<br>tex1Dproj(sampler, uv)\t\t\t- Samples a texture using a projective divide; the UV is divided by uv.w before the lookup takes place.<br>... same thing for tex2D and tex3D<br>Yes there are 3d textures, imagine a volume cloud, would be really cool. Source has support for them, however the interface for creating them is incomplete.<br>texCUBE(sampler, reflectuv)\t\t- samples a cubemap<br>texCUBEgrad - ...<br>...<br>...","iscode":false,"isvdccode":false,"contents":[]}],"selfid":"3f24fd71920091075769d40600d91881"}