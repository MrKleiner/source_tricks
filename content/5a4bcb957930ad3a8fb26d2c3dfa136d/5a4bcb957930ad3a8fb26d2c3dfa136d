{"atitle":"Quick guide for Lizard vmf python library","boxes":[{"text":"The main purpose of this library is to provide you with a parsed vmf in a form of XML tree and reconstructor which builds a valid vmf out of the given XML tree.<div><br></div><div>It has a lot of other functions and the most notable ones are solid and entity creators/manipulators.</div><div><br></div><div>(this is my face after I wasted days on writing this rubbish library)</div>","contents":[{"imguseurl":"1","imgsize":"300","imgurl":"content/5a4bcb957930ad3a8fb26d2c3dfa136d/data/74a1b458dad28eaf770f9068c5cd68d9.png"}],"border_w":"5px 0px 0px","border_c":"rgb(100, 218, 255)","chapter":""},{"text":"You can create the Lizard vmf class by importing it from the library and passing a vmf string to it. It has to be a valid vmf string OR a statement whether to create new vmf or not.<div><div>Some vmfs exported with virgin WallWorm for virgin 3DS Max may not work.</div><div><br></div><div>This class is capable of parsing any version of vmf for any game starting from OrangeBox.</div><div>The process is fully lossless, BUT, as of now there are only two limitations <i>for now</i>:</div><div>- The quickhide is not preserved.</div><div>- If an object was assigned to more than 1 visgroup, only the last one will be preserved.</div></div><div><br></div>","contents":[],"border_w":"5px 0px 0px","border_c":"rgb(160, 100, 255)","chapter":"Initializing and Basics"},{"text":"<div>from lizardvmf import lizardvmf</div><div><br></div><div>shitty_gmod_rp_map = open('C:\\\\stuff\\\\overambitious_gmod_rp_project\\\\rp_bangclaw_v42069.vmf', 'r').read()</div><div><br></div><div>iguana = lizardvmf(shitty_gmod_rp_map)</div><div>print(iguana.mapsettings['skyname'])</div><div class=\"\"># sky_day01_01</div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"# Sometimes, you may want to initialize a new vmf from scrap. To do this - pass True instead of string. A new vmf will be created with some defaults set.<div><br></div><div><div>iguana = lizardvmf(True)</div><div>print(iguana.mapsettings['skyname'])</div></div><div class=\"\"># sky_day01_01</div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(160, 100, 255)","chapter":"","iscode":true},{"text":"To convert/export the class back to a valid vmf string - call tovmf() on the lizardvmf object:<div><br></div><div>iguana = lizardvmf(True)<br></div><div>print(iguana.tovmf())<br></div><div><br></div>","contents":[],"border_w":"5px 0px 0px","border_c":"rgb(160, 100, 255)","chapter":""},{"text":"You can access some basic stats of the vmf with vmfstats() method:<div><br></div><div>print(iguana.vmfstats())</div><div><br></div><div>It returns a dictionary where:</div><div><br></div><div>ents_enum_edict - entity limit which actually matters (such as dynamic props with names), usually limited to 4096 or 8192.</div><div>ents_total - total amount of entities, including static props which don't contribute to entity limit.<br></div><div>faces_enum_edict - the amount of brush faces per vmf IS limited. It's 65536/2 = 32768. Nodraw does not count.<br></div><div>faces_total - total amount of faces, including the ones with nodraw.<br></div><div>brushes_edict - every single brush contributes to the total brush limit which is usually 8192.<br></div><div><br></div><div>{</div><div>  'ents_enum_edict': 29, </div><div>  'ents_total': 32, </div><div>  'faces_enum_edict': 219, </div><div>  'faces_total': 230, </div><div>  'brushes_edict': 29</div><div>}<br></div><div><br></div>","contents":[],"border_w":"5px 0px 0px","border_c":"rgb(160, 100, 255)","chapter":""},{"text":"<b><font color=\"#fe5858\">Object types</font></b><div><br></div><div><br></div>","contents":[],"border_w":"5px 0px 0px","border_c":"rgb(100, 218, 255)","chapter":"Object types"},{"text":"<b>Entity</b><div><b><br></b></div><div>Every entity has key:value pairs (paramters). This can be accessed via .prms parameter of the lizard entity and treated as a dictionary:</div>","contents":[],"border_w":"5px 0px 0px","border_c":"rgb(160, 100, 255)","chapter":"Entity object"},{"text":"<div>iguana = lizardvmf(True)<br></div><div><br></div><div><br></div><div>select_entity = iguana.ents[0]</div><div><br></div><div>print(select_entity.prms['targetname'])</div><div class=\"\"># entrance_door</div><div><br></div><div>select_entity['targetname'] = 'rubbish_bin'<br></div><div><br></div><div><div>print(select_entity.prms['targetname'])</div><div class=\"\"># rubbish_bin</div></div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"<div class=\"\"># .prmquery</div># For whatever reason, a prmquery exists... It's basically a query to either find a key by its value...<div><br></div><div><div>iguana = lizardvmf(True)<br></div><div><br></div><div>select_entity = iguana.ents[0]</div></div><div><br></div><div>select_entity.prmquery(None, 'rubbish_bin')<br></div><div class=\"\"># 'targetname'</div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"<div class=\"\"># .visgroup</div># You can assign the entity to the visgroup by either a visgroup name (in case of duplicate names - the first match is used)<div><br></div><div>iguana = lizardvmf(True)<br></div><div>select_entity = iguana.ents[0]<br></div><div><br></div><div>select_entity.visgroup<br></div><div class=\"\"># {\n# \t'id': '3',\n# \t'name': 'rubbish_details'\n# }<br></div><div><br></div><div><br></div><div class=\"\"># pass a string to try to assign by name (if not found - ignore)</div><div>select_entity.visgroup = 'bordello'<br></div><div><div>select_entity.visgroup<br></div><div class=\"\"># {\n# \t'id': '17',\n# \t'name': 'bordello'\n# }</div></div><div><br></div><div><br></div><div class=\"\"><div class=\"\"># pass an integer to try to assign by id (if not found - ignore)</div><div>select_entity.visgroup = 69<br></div><div><div>select_entity.visgroup<br></div><div class=\"\"># {\n# \t'id': '69',\n# \t'name': 'lizard_pussy'\n# }</div></div></div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"<div class=\"\"># .add_solid()</div># You can assign a world solid to the entity with .add_solid() either by solid class or solid id<div class=\"\"># In case solid has displacements - the request is ignored</div><div class=\"\"># it's ok to infinitely assign same solid to the same entity</div><div class=\"\"># if you pass something malformed - the request will be ignored</div><div><br></div><div><div>iguana = lizardvmf(True)<br></div><div>select_entity = iguana.ents[0]</div></div><div><br></div><div>len(select_entity.solids())<br></div><div class=\"\"># 0</div><div><br></div><div class=\"\"># pass an integer to append by id<br></div><div>select_entity.add_solid(37)<br></div><div><div>len(select_entity.solids())<br></div><div class=\"\"># 1</div></div><div><br></div><div>mysolid = iguana.solids()[0]</div><div><br></div><div class=\"\"># pass solid class to append by solid class<br></div><div><div>select_entity.add_solid(mysolid)<br></div><div><div>len(select_entity.solids())<br></div><div class=\"\"># 2</div></div></div><div><br></div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"<div class=\"\"># .solids()</div># You can get an array of all solids of the current entity, if any<div><br></div><div><div><div>iguana = lizardvmf(True)<br></div><div><br></div><div>select_entity = iguana.ents[0]</div></div><div>len(select_entity.solids())<br></div><div class=\"\"># 0</div></div><div><br></div><div><br></div><div><div>select_entity = iguana.ents[1]</div><div>len(select_entity.solids())<br></div><div class=\"\"># 3</div></div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"# .connections<div class=\"\"># basically, the IO system</div><div class=\"\"># you can get an object which is a list of all connections (if any)</div><div><br></div><div><div>iguana = lizardvmf(True)<br></div><div><br></div><div class=\"\"># access the list of connections via .items property</div><div>select_entity = iguana.ents[0]</div></div><div>len(select_entity.connections.items)<br></div><div class=\"\"># 5</div><div><br></div><div class=\"\"># if entity has no connections at all - you'll have to enable them before adding new ones</div><div><div>select_entity = iguana.ents[1]</div><div>select_entity.connections<br></div><div class=\"\"># False</div></div><div><br></div><div>select_entity.connections = True<br></div><div><div>len(select_entity.connections.items)<br></div><div class=\"\"># 0</div></div><div><br></div><div class=\"\"># Set back to False to delete all existing connections and make this entity has no connections at all</div><div>select_entity.connections = False<br></div><div><div>select_entity.connections<br></div><div class=\"\"># False</div></div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"# A single connection is an object you can manipulate<div><br></div><div><div>iguana = lizardvmf(True)</div><div>select_entity = iguana.ents[0]</div></div><div><br></div><div>select_entity.connections.items[0].delay<br></div><div class=\"\"># 1.3</div><div><br></div><div><div>select_entity.connections.items[0].delay = 0<br></div><div class=\"\"># 0.0</div></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"<div>Every connection has all the parameters it does in hammer:</div><div><br></div><div>output_name - My output named, like \"OnPressed\"<br></div><div>tgt_ents - Target entities named\naction - Via this input\nparams - With a parameter override of\ndelay - Fire after delay in seconds of (accepts ints and floats)\nrefire_limit - Limit to this many fires (-1 = infinite) (accepts ints and floats)</div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":""},{"text":"# To add a connection to the connections of the entity - use .add()<div><br></div><div><div><div>iguana = lizardvmf(True)</div><div>select_entity = iguana.ents[0]</div></div><div><br></div><div>select_entity.connections.items[0].delay<br></div><div class=\"\"># Error</div><div><br></div><div class=\"\"># create a dictionary of entity parameters</div><div class=\"\"># dict names are the same as entity parameters described above</div><div><br></div><div>newconnection = {\n\t'tgt_ents': 'botle',\n\t'action': 'SetAnimation',\n\t'params': 'roll',</div><div>\t'delay': 2.73,\n\t'refire_limit': -1\n}<br></div><div><br></div><div class=\"\"># .add() takes two positional arguments:</div><div class=\"\"># Connection type, like \"OnPressed\"</div><div class=\"\"># and a dictionary of other parameters (all parameters are obligatory)</div><div><br></div><div class=\"\"># the connection type is specified separately</div><div>select_entity.connections.add('OnPressed', newconnection)</div></div><div><br></div><div><div>select_entity.connections.items[0].delay<br></div><div class=\"\"># 2.73</div></div><div><br></div><div><div>select_entity.connections.items[0].delay = 1.25</div></div><div><br></div><div><div>select_entity.connections.items[0].delay<br></div><div class=\"\"># 1.25</div></div><div><br></div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"<b>Solid</b><div><b><br></b></div><div>Displacements cannot be manipulated/created yet.<b><br></b></div><div><br></div>","contents":[],"border_w":"5px 0px 0px","border_c":"rgb(160, 100, 255)","chapter":"Solid object"},{"text":"<div class=\"\"># A solid can belong to an entity, you can make it a world solid again by calling .toworld() on the solid object.<br></div><div><br></div><div><div>iguana = lizardvmf(True)</div><div><div><div><br></div><div>select_entity = iguana.ents[0]</div></div><div>len(select_entity.solids())</div></div></div><div class=\"\"># 1</div><div><br></div><div><div>select_entity = iguana.ents[0]</div><div>select_entity.solids()[0].toworld()<br></div><div>len(select_entity.solids())</div></div><div class=\"\"># 0</div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"# You can check which entity this solid belongs to<div><div>iguana = lizardvmf(True)</div><div><div><div><br></div><div>select_entity = iguana.ents[0]</div></div><div>select_entity.solids()[0].entity.prms['classname']</div></div></div><div class=\"\"># func_detail</div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"# You can also assign the solid to an entity on solid's behalf with .toent()<div><br></div><div><div>iguana = lizardvmf(True)</div><div><div><div><br></div><div>select_solid = iguana.solids[0]</div></div><div><br></div><div>select_solid.entity<br></div></div></div><div class=\"\"># False</div><div><br></div><div class=\"\"># .toent() takes one argument which is either an integer representing the entity id or an entity object<br></div><div>select_solid.toent(1337)<br></div><div><br></div><div><div>select_solid.entity.prms['classname']<br></div><div class=\"\"># func_button</div></div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"Brushes have faces, you can access the array of faces via .sides()<div>If solid was made with hammer++ then it has a full set of verts that you can access, but not set.</div><div>Every solid side has a number of parameters, but the only ones that you may want to access are \"material\" and \"lightmapscale\".</div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":""},{"text":"<div class=\"\">#</div># If you're using hammer++ - you can get all the verts of the side, but not set them<div class=\"\">#</div><div><br><div><div>iguana = lizardvmf(True)</div><div><div><br></div><div>select_solid = iguana.solids[0]</div></div></div></div><div><br></div><div class=\"\"># get all sides <br></div><div>solid_sides = select_solid.sides()</div><div><br></div><div class=\"\"># You can access face parameters via .prms and treating it as a dictionary:</div><div><br></div><div><br></div><div class=\"\"># Set material</div><div><br></div><div>solid_sides[0].prms['material']<br></div><div class=\"\"># BRICK/BRICKFLOOR001A</div><div><br></div><div>solid_sides[0].prms['material'] = 'TOOLS/TOOLSNODRAW'<br></div><div><br></div><div>solid_sides[0].prms['material']<br></div><div class=\"\"># TOOLS/TOOLSNODRAW</div><div><br></div><div><br></div><div><br></div><div class=\"\"># Set lightmap scale</div><div><div>solid_sides[0].prms['lightmapscale']<br></div><div class=\"\"># 16</div><div><br></div><div>solid_sides[0].prms['lightmapscale'] = 4<br></div><div><br></div><div>solid_sides[0].prms['lightmapscale']</div></div><div class=\"\"># 4</div><div><br></div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"<b>Shared Methods (visgroups, groups, deleting)</b><div><b><br></b></div><div>Things like deleting stuff, grouping and assigning to visgroups...</div><div><br></div>","contents":[],"border_w":"5px 0px 0px","border_c":"rgb(160, 100, 255)","chapter":"Shared Methods (visgroups, groups, deleting)"},{"text":"<i><font color=\"#ffffff\">Visgroups.</font></i><div><i><br></i><div>Main thing is - you always have to create a visgroup before assigning anything to it. All invalid requests will be ignored with no error messages (in current version for sure)</div><div><br></div></div>","contents":[],"border_w":"5px 0px 0px","border_c":"rgb(100, 218, 255)","chapter":""},{"text":"# You can get an array of all visgroups of the current vmf via .visgroups() method of the lizardvmf object<div><br></div><div>iguana = lizardvmf(True)<br></div><div><br></div><div>all_visgroups = lizardvmf.visgroups()</div><div>all_visgroups[0].name<br></div><div class=\"\"># stripclub</div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"<div>The visgroup is an object you can manipulate. Visgroups can have children and parents. While you cannot access its parent (why would you do that ??) - you can create child visgroups, set any parameters on the existing ones and properly delete them.<br></div><div>Note that initially you have no visgroups and therefore you have to create a new one via lizardvmf object.</div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":""},{"text":"<div class=\"\"># Create first visgroup or rather a visgroup in the root of the hammer visgroups pool<br></div><div><br></div><div>iguana = lizardvmf(True)<br></div><div>len(iguana.visgroups())</div><div class=\"\"># 0</div><div><br></div><div class=\"\"># Pass string to specify a name (cannot be otherwise)</div><div>iguana.new_visgroup('street')<br></div><div><br></div><div><div>len(iguana.visgroups())</div><div class=\"\"># 1</div></div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"# Now, create a child visgroup. <i>YES, it uses a different method</i><div><br></div><div class=\"\"># Returns a visgroup object</div><div>fresh_visgroup = iguana.visgroups()[0].add_new('shop')<br></div><div><br></div><div>fresh_visgroup.name<br></div><div class=\"\"># shop</div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"<div># Now that there are a few visgroups - it could be required to select one by its name... <br></div><div># You can do that by using .visgroups(), but this time passing a string</div><div><br></div><div>len(iguana.visgroups('street'))<br></div><div># 1</div><div><br></div><div># Upcoming feature: Get child visgroups and all the objects assigned to this visgroup</div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"Now that there are some visgroups - it's possible to assign entities and solids to them.<div>There are two types of objects that support visgroup assignation: Entity and Solid (simply because there are no other kinds of objects in .vmf struct).</div><div><br></div><div>Both entity and solid have a .visgroup parameter.</div><div><br></div><div>Syntax is the same for both. Assignation happens on object's behalf, not visgroup's.</div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":""},{"text":"<div># (continuing from the example above)<br></div><div><br></div><div># select an entity/solid</div><div>ent_to_vis = iguana.ents[0]<br></div><div><br></div><div><br></div><div># If nothing passed - returns a dict with visgroup info (if any, otherwise - empty dict)</div><div>ent_to_vis.visgroup<br></div><div># {'id':'','name':''}</div><div><br></div><div># Pass int to assign by group id, pass string to assign by group name (first match in case of duplicate names)</div><div>ent_to_vis.visgroup = 'street'<br></div><div><br></div><div><div>ent_to_vis.visgroup<br></div><div>#{\n#\t'id': '3',\n#\t'name': 'street'\n#}</div></div><div><br></div><div># This will be changed soon: It will return a visgroup object</div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"<i>Groups</i><div><br></div><div>Will be implemented in the next update.</div><div><br></div>","contents":[],"border_w":"5px 0px 0px","border_c":"rgb(100, 218, 255)","chapter":""},{"text":"<div class=\"\"># grouping<br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"<div><i>Deleting</i><br></div><div><i><br></i></div><div>Solid, visgroup, entity and outputs have a .kill() method</div><div><br></div>","contents":[],"border_w":"5px 0px 0px","border_c":"rgb(100, 218, 255)","chapter":""},{"text":"<div><div>iguana = lizardvmf(True)<br></div><div>select_entity = iguana.ents[0]</div></div><div>len(iguana.ents)</div><div class=\"\"># 3</div><div><br></div><div>select_entity.kill()<br></div><div><br></div><div><div>len(iguana.ents)</div><div class=\"\"># 2</div></div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"<div><b>Map specific: Cordons, map settings, vmf search queries and utility functions</b><br></div><div><b><br></b></div>","contents":[],"border_w":"5px 0px 0px","border_c":"rgb(160, 100, 255)","chapter":"Map specific: Cordons, settings ..."}],"selfid":"5a4bcb957930ad3a8fb26d2c3dfa136d"}