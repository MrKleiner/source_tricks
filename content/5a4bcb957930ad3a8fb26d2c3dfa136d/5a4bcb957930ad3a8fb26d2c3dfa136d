{"atitle":"Quick guide for Lizard vmf python library","boxes":[{"text":"The main purpose of this library is to provide you with a parsed vmf in a form of XML tree and reconstructor which builds a valid vmf out of the given XML tree.<div><br></div><div>It has a lot of other functions and the most notable ones are solid and entity creators/manipulators.</div><div><br></div><div>(this is my face after I wasted days on writing this rubbish library)</div>","contents":[{"imguseurl":"1","imgsize":"300","imgurl":"content/5a4bcb957930ad3a8fb26d2c3dfa136d/data/74a1b458dad28eaf770f9068c5cd68d9.png"}],"border_w":"5px 0px 0px","border_c":"rgb(100, 218, 255)","chapter":""},{"text":"You can create the Lizard vmf class by importing it from the library and passing a vmf string to it. It has to be a valid vmf string OR a statement whether to create new vmf or not.<div><div>Some vmfs exported with virgin WallWorm for virgin 3DS Max may not work.</div><div><br></div><div>This class is capable of parsing any version of vmf for any game starting from OrangeBox.</div><div>The process is fully lossless, BUT, as of now there are only two limitations <i>for now</i>:</div><div>- The quickhide is not preserved.</div><div>- If an object was assigned to more than 1 visgroup, only the last one will be preserved.</div></div><div><br></div>","contents":[],"border_w":"5px 0px 0px","border_c":"rgb(160, 100, 255)","chapter":"Initializing and Basics"},{"text":"<div>from lizardvmf import lizardvmf</div><div><br></div><div>shitty_gmod_rp_map = open('C:\\\\stuff\\\\overambitious_gmod_rp_project\\\\rp_bangclaw_v42069.vmf', 'r').read()</div><div><br></div><div>iguana = lizardvmf(shitty_gmod_rp_map)</div><div>print(iguana.mapsettings['skyname'])</div><div># sky_day01_01</div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"# Sometimes, you may want to initialize a new vmf from scrap. To do this - pass True instead of string. A new vmf will be created with some defaults set.<div><br></div><div><div>iguana = lizardvmf(True)</div><div>print(iguana.mapsettings['skyname'])</div></div><div># sky_day01_01</div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(160, 100, 255)","chapter":"","iscode":true},{"text":"To convert/export the class back to a valid vmf string - call tovmf() on the lizardvmf object:<div><br></div><div>iguana = lizardvmf(True)<br></div><div>print(iguana.tovmf())<br></div><div><br></div>","contents":[],"border_w":"5px 0px 0px","border_c":"rgb(160, 100, 255)","chapter":""},{"text":"You can access some basic stats of the vmf with vmfstats() method:<div><br></div><div>print(iguana.vmfstats())</div><div><br></div><div>It returns a dictionary where:</div><div><br></div><div>ents_enum_edict - entity limit which actually matters (such as dynamic props with names), usually limited to 4096 or 8192.</div><div>ents_total - total amount of entities, including static props which don't contribute to entity limit.<br></div><div>faces_enum_edict - the amount of brush faces per vmf IS limited. It's 65536/2 = 32768. Nodraw does not count.<br></div><div>faces_total - total amount of faces, including the ones with nodraw.<br></div><div>brushes_edict - every single brush contributes to the total brush limit which is usually 8192.<br></div><div><br></div><div>{</div><div>  'ents_enum_edict': 29, </div><div>  'ents_total': 32, </div><div>  'faces_enum_edict': 219, </div><div>  'faces_total': 230, </div><div>  'brushes_edict': 29</div><div>}<br></div><div><br></div>","contents":[],"border_w":"5px 0px 0px","border_c":"rgb(160, 100, 255)","chapter":""},{"text":"<b><font color=\"#fe5858\">Object types</font></b><div><br></div><div><br></div>","contents":[],"border_w":"5px 0px 0px","border_c":"rgb(100, 218, 255)","chapter":"Object types"},{"text":"<b>Entity</b><div><b><br></b></div><div>Every entity has key:value pairs (paramters). This can be accessed via .prms parameter of the lizard entity and treated as a dictionary:</div>","contents":[],"border_w":"5px 0px 0px","border_c":"rgb(160, 100, 255)","chapter":"Entity object"},{"text":"<div>iguana = lizardvmf(True)<br></div><div><br></div><div><br></div><div>select_entity = iguana.ents[0]</div><div><br></div><div>print(select_entity.prms['targetname'])</div><div># entrance_door</div><div><br></div><div>select_entity['targetname'] = 'rubbish_bin'<br></div><div><br></div><div><div>print(select_entity.prms['targetname'])</div><div># rubbish_bin</div></div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"<div># .prmquery</div># For whatever reason, a prmquery exists... It's basically a query to either find a key by its value...<div><br></div><div><div>iguana = lizardvmf(True)<br></div><div><br></div><div>select_entity = iguana.ents[0]</div></div><div><br></div><div>select_entity.prmquery(None, 'rubbish_bin')<br></div><div># 'targetname'</div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"<div># .visgroup</div># You can assign the entity to the visgroup by either a visgroup name (in case of duplicate names - the first match is used)<div><br></div><div>iguana = lizardvmf(True)<br></div><div>select_entity = iguana.ents[0]<br></div><div><br></div><div>select_entity.visgroup<br></div><div># {\n# \t'id': '3',\n# \t'name': 'rubbish_details'\n# }<br></div><div><br></div><div><br></div><div># pass a string to try to assign by name (if not found - ignore)</div><div>select_entity.visgroup = 'bordello'<br></div><div><div>select_entity.visgroup<br></div><div># {\n# \t'id': '17',\n# \t'name': 'bordello'\n# }</div></div><div><br></div><div><br></div><div><div># pass an integer to try to assign by id (if not found - ignore)</div><div>select_entity.visgroup = 69<br></div><div><div>select_entity.visgroup<br></div><div># {\n# \t'id': '69',\n# \t'name': 'lizard_pussy'\n# }</div></div></div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"<div># .add_solid()</div># You can assign a world solid to the entity with .add_solid() either by solid class or solid id<div># In case solid has displacements - the request is ignored</div><div># it's ok to infinitely assign same solid to the same entity</div><div># if you pass something malformed - the request will be ignored</div><div><br></div><div><div>iguana = lizardvmf(True)<br></div><div>select_entity = iguana.ents[0]</div></div><div><br></div><div>len(select_entity.solids())<br></div><div># 0</div><div><br></div><div># pass an integer to append by id<br></div><div>select_entity.add_solid(37)<br></div><div><div>len(select_entity.solids())<br></div><div># 1</div></div><div><br></div><div>mysolid = iguana.solids()[0]</div><div><br></div><div># pass solid class to append by solid class<br></div><div><div>select_entity.add_solid(mysolid)<br></div><div><div>len(select_entity.solids())<br></div><div># 2</div></div></div><div><br></div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"<div># .solids()</div># You can get an array of all solids of the current entity, if any<div><br></div><div><div><div>iguana = lizardvmf(True)<br></div><div><br></div><div>select_entity = iguana.ents[0]</div></div><div>len(select_entity.solids())<br></div><div># 0</div></div><div><br></div><div><br></div><div><div>select_entity = iguana.ents[1]</div><div>len(select_entity.solids())<br></div><div># 3</div></div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"# .connections<div># basically, the IO system</div><div># you can get an object which is a list of all connections (if any)</div><div><br></div><div><div>iguana = lizardvmf(True)<br></div><div><br></div><div># access the list of connections via .items property</div><div>select_entity = iguana.ents[0]</div></div><div>len(select_entity.connections.items)<br></div><div># 5</div><div><br></div><div># if entity has no connections at all - you'll have to enable them before adding new ones</div><div><div>select_entity = iguana.ents[1]</div><div>select_entity.connections<br></div><div># False</div></div><div><br></div><div>select_entity.connections = True<br></div><div><div>len(select_entity.connections.items)<br></div><div># 0</div></div><div><br></div><div># Set back to False to delete all existing connections and make this entity has no connections at all</div><div>select_entity.connections = False<br></div><div><div>select_entity.connections<br></div><div># False</div></div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"# A single connection is an object you can manipulate<div><br></div><div><div>iguana = lizardvmf(True)</div><div>select_entity = iguana.ents[0]</div></div><div><br></div><div>select_entity.connections.items[0].delay<br></div><div># 1.3</div><div><br></div><div><div>select_entity.connections.items[0].delay = 0<br></div><div># 0.0</div></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"<div>Every connection has all the parameters it does in hammer:</div><div><br></div><div>output_name - My output named, like \"OnPressed\"<br></div><div>tgt_ents - Target entities named\naction - Via this input\nparams - With a parameter override of\ndelay - Fire after delay in seconds of (accepts ints and floats)\nrefire_limit - Limit to this many fires (-1 = infinite) (accepts ints and floats)</div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":""},{"text":"# To add a connection to the connections of the entity - use .add()<div><br></div><div><div><div>iguana = lizardvmf(True)</div><div>select_entity = iguana.ents[0]</div></div><div><br></div><div>select_entity.connections.items[0].delay<br></div><div># Error</div><div><br></div><div># create a dictionary of entity parameters</div><div># dict names are the same as entity parameters described above</div><div><br></div><div>newconnection = {\n\t'tgt_ents': 'botle',\n\t'action': 'SetAnimation',\n\t'params': 'roll',</div><div>\t'delay': 2.73,\n\t'refire_limit': -1\n}<br></div><div><br></div><div># .add() takes two positional arguments:</div><div># Connection type, like \"OnPressed\"</div><div># and a dictionary of other parameters (all parameters are obligatory)</div><div><br></div><div># the connection type is specified separately</div><div>select_entity.connections.add('OnPressed', newconnection)</div></div><div><br></div><div><div>select_entity.connections.items[0].delay<br></div><div># 2.73</div></div><div><br></div><div><div>select_entity.connections.items[0].delay = 1.25</div></div><div><br></div><div><div>select_entity.connections.items[0].delay<br></div><div># 1.25</div></div><div><br></div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"<b>Solid</b><div><b><br></b></div><div>Displacements cannot be manipulated/created yet.<b><br></b></div><div><br></div>","contents":[],"border_w":"5px 0px 0px","border_c":"rgb(160, 100, 255)","chapter":"Solid object"},{"text":"<div># A solid can belong to an entity, you can make it a world solid again by calling .toworld() on the solid object.<br></div><div><br></div><div><div>iguana = lizardvmf(True)</div><div><div><div><br></div><div>select_entity = iguana.ents[0]</div></div><div>len(select_entity.solids())</div></div></div><div># 1</div><div><br></div><div><div>select_entity = iguana.ents[0]</div><div>select_entity.solids()[0].toworld()<br></div><div>len(select_entity.solids())</div></div><div># 0</div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"# You can check which entity this solid belongs to<div><div>iguana = lizardvmf(True)</div><div><div><div><br></div><div>select_entity = iguana.ents[0]</div></div><div>select_entity.solids()[0].entity.prms['classname']</div></div></div><div># func_detail</div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"# You can also assign the solid to an entity on solid's behalf with .toent()<div><br></div><div><div>iguana = lizardvmf(True)</div><div><div><div><br></div><div>select_solid = iguana.solids[0]</div></div><div><br></div><div>select_solid.entity<br></div></div></div><div># False</div><div><br></div><div># .toent() takes one argument which is either an integer representing the entity id or an entity object<br></div><div>select_solid.toent(1337)<br></div><div><br></div><div><div>select_solid.entity.prms['classname']<br></div><div># func_button</div></div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true},{"text":"Brushes have faces, you can access the array of faces via .sides()<div>If solid was made with hammer++ then it has a full set of verts that you can access, but not set.</div><div>Every solid side has a number of parameters, but the only ones that you may want to access are \"material\" and \"lightmapscale\".</div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":""},{"text":"<div>#</div># If you're using hammer++ - you can get all the verts of the side, but not set them<div>#</div><div><br><div><div>iguana = lizardvmf(True)</div><div><div><br></div><div>select_solid = iguana.solids[0]</div></div></div></div><div><br></div><div># get all sides <br></div><div>solid_sides = select_solid.sides()</div><div><br></div><div># You can access face parameters via .prms and treating it as a dictionary:</div><div><br></div><div><br></div><div># Set material</div><div><br></div><div>solid_sides[0].prms['material']<br></div><div># BRICK/BRICKFLOOR001A</div><div><br></div><div>solid_sides[0].prms['material'] = 'TOOLS/TOOLSNODRAW'<br></div><div><br></div><div>solid_sides[0].prms['material']<br></div><div># TOOLS/TOOLSNODRAW</div><div><br></div><div><br></div><div><br></div><div># Set lightmap scale</div><div><div>solid_sides[0].prms['lightmapscale']<br></div><div># 16</div><div><br></div><div>solid_sides[0].prms['lightmapscale'] = 4<br></div><div><br></div><div>solid_sides[0].prms['lightmapscale']</div></div><div># 4</div><div><br></div><div><br></div>","contents":[],"border_w":"0px","border_c":"rgb(100, 218, 255)","chapter":"","iscode":true}],"selfid":"5a4bcb957930ad3a8fb26d2c3dfa136d"}